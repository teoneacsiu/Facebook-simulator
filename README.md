##   - victor.neacsiu 311CA

#   Task 1: Friend Network Management

## Overview

>   In this task, we are tasked with managing a social network where users can
form and dissolve friendships, calculate distances between each other, receive
friend suggestions, and find common friends. The underlying data structure used
to represent these relationships is an adjacency matrix. Each row and column in
the matrix corresponds to a user, and an entry of 1 in the matrix indicates a
friendship between two users.

## Implementation

>   The implementation involves several key operations: adding and removing
friends, suggesting friends, calculating the distance between two users,
identifying common friends, counting the number of friends a user has, and
finding the most popular friend. Here’s a detailed breakdown of how each
operation is implemented:

### Adding a Friend

>   To add a friend, the <add_friend> function is used. This function updates
the adjacency matrix to reflect the new bidirectional friendship. Specifically,
it sets the matrix entries corresponding to the two users to 1, indicating that
they are now friends. A message confirming the addition is then printed.

### Removing a Friend

>   The <remove_friend> function handles the removal of a friendship. It 
updates the adjacency matrix by setting the relevant entries to 0, thus
breaking the friendship link between the two users. A confirmation message is
printed to inform the user of the successful removal.

### Suggesting Friends

>   Friend suggestions are generated by the <suggestions> function. This
function looks at the friends of a user’s friends (second-degree connections)
and suggests them if they are not already direct friends. It uses a frequency
array to track potential suggestions and ensures no duplicate suggestions are
made. If no suggestions are found, an appropriate message is displayed.

### Calculating Distance Between Users

>   The distance between two users is calculated using the <distance> function.
This function employs the Breadth-First Search (BFS) algorithm to find the
shortest path in terms of friendships between the two users. If a path exists,
the function returns the number of connections (or hops) required to traverse
from one user to the other. If no path exists, it returns -1 and a message is
printed indicating that there is no way to connect the two users.

### Finding Common Friends

>   The <common> function identifies common friends between two users. It
iterates through the list of friends for both users and prints out those who
are friends with both. If there are no common friends, a message is printed to
inform the user.

### Counting Friends

>   The number of friends a user has is counted by the <friends> function. This
function iterates through the user’s row in the adjacency matrix, counting the
number of entries that are set to 1. The total count is then printed.

### Finding the Most Popular Friend

>   The <popular> function determines the most popular friend of a given user.
Popularity is defined by the number of friends a user has. The function counts
the friends for each of the user's friends and identifies the one with the
highest count. If there is a tie, the given user themselves is considered the
most popular. The result is then printed.

#   Task 2: Posts and Reposts Management

## Overview

>   In this task, we're managing a social media platform where users can create
posts, repost existing ones, like posts and reposts, and retrieve various
information about these interactions. The structure we use to manage this is a
tree, where each post can have multiple reposts, forming a hierarchy.

## Implementation

>   The implementation involves several key operations: creating posts,
reposting posts, liking posts, finding common reposts, deleting posts, and
retrieving reposts. Here’s a detailed breakdown of how each operation is
implemented:

### Creating a Post

>   When a user creates a post, the system first checks if the user exists. If
they do, a new post is created with a unique ID and the specified title. This
post is then added to a list of all posts. The system prints a confirmation
message to let the user know that their post has been created successfully.

### Reposting a Post

>   Reposting allows a user to take an existing post and share it again, either
as a direct repost of the original or as a repost of another repost. The system
finds the original post and, if necessary, the specific repost being shared. A
new repost is created, linked to its parent post or repost, and a confirmation
message is displayed.

### Liking a Post

>   Users can like or unlike posts and reposts. The system checks if the user
has already liked the post. If they have, it unlikes it and decreases the like
count; if they haven't, it likes the post and increases the like count. A
message informs the user of their action (like or unlike).

### Finding Common Reposts

>   When two reposts of the same original post are compared, the system can
identify their first common repost ancestor. It traces the paths from the
original post to each repost and finds where these paths intersect. The ID of
this common repost is then printed.

### Deleting a Post

>   Deleting a post is a bit more involved. The system finds the target post or
repost, removes it from the list, and then recursively deletes all its child
reposts. This ensures that no orphaned reposts are left in the system. A
confirmation message is printed once the deletion is complete.

### Retrieving Reposts

>   Users can retrieve and view all reposts of a specific post or repost. The
system traverses the repost hierarchy and prints the details of each repost,
showing the user the entire chain of reposts linked to the original post.

#   Task 3: Social Media Feed Management

## Overview

>   In this task, we handle the functionality that allows users to interact
with their social media feed and profile. Users can view their feed to see the
latest posts from themselves and their friends, check their profile to see all
their posts and reposts, find out which friends have reposted a specific post,
and identify their closest group of friends (or clique). The relationships
between users are managed using an adjacency matrix, while posts and reposts
are stored in a linked list structure.

## Viewing the Feed

>   When a user wants to check their feed, the system gathers the most recent
posts from both the user and their friends. To do this, the system first goes
through all the posts and counts them, then stores these posts in an array so
it can easily access and sort them. Starting from the most recent post, it
checks if each post was made by the user or by one of their friends, which is
determined by looking up the user IDs in the adjacency matrix. For each post
that qualifies, it prints the post until it reaches the specified feed size.
This way, if Mihai wants to see his latest feed, the system will gather all
posts, filter out the ones made by Mihai and his friends, and display the most
recent ones up to the number he asked for.

### Viewing a User Profile

>   When a user wants to see all their posts and reposts, the system performs a
thorough scan through all existing posts and reposts. It goes through every
post to see if it was made by the user and, if it finds one, it prints the post
title. The system then checks each post’s reposts to see if the user has
reposted it. If the user has reposted it, the system prints a message
indicating that the user reposted the original post. This way, if Mihai wants
to view his profile, the system will list all his posts and any reposts he's
made.

### Finding Friends Who Reposted

>   To find out which friends have reposted a specific post, the system looks
at the reposts of that post and checks each reposting user's relationship with
the original user. The system first finds the original post by its ID, then it
goes through each repost of that post and checks if the reposter is a friend of
the user by looking at the adjacency matrix. If a reposting user is a friend,
their name is printed. For example, if Mihai wants to know which friends
reposted his post ID 3, the system will find that post, check its reposts, and
list the friends who did the reposting.

### Identifying the Closest Friend Group

>   Finding the closest friend group, or clique, involves identifying the
largest group of friends where everyone is connected to each other. The system
evaluates all possible subsets of the user's friends to find the largest fully
connected group. It first retrieves the list of the user’s friends, then
generates all possible friend combinations (subsets) and checks each to see if
all members are friends with each other. The system keeps track of the largest
clique found. Once all subsets have been checked, it sorts the clique members
and prints them. For instance, if Mihai wants to know his closest group of
friends, the system will look at all his friends, test all combinations, and
find the largest group where everyone is friends with each other.

#   Conclusions and opinions

>   During this homework, we learned how a social network like Facebook really
works in real life. This time, given the fact that we had to work in pairs, we
also learned to work well in a team. We contributed together to all the tasks,
complementing each other in writing the code. We learned that together we can 
achieve good results faster than working alone. It was really a good experience
for us which we can use for our good in our next careers.

 
